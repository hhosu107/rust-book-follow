# 10_3 Validating References with Lifetimes

Lifetime은 우리가 이미 사용하고 있는 또다른 형태의 generic입니다. 타입이 특정
behavior를 가지는 것과 달리, lifetime은 우리가 reference를 필요로 하는 시간 동안
유효하도록 해줍니다.

Ch 4에서 References and borrowing을 배울 때 다루지 않은 것이 있는데, 그것이 바로
Rust가 lifetime을 가진다는 것입니다. lifetime은 reference가 valid한 scope입니다.
대개 lifetime은 묵시적이고 추론됩니다. 타입이 그렇듯이요. 우리가 여러 타입이
가능할 때만 타입을 반드시 명시해야 하듯이, reference의 lifetime이 몇 가지 다른
방식으로 결정될 수 있을 때에만 lifetime을 명시해줘야 합니다.

Rust는 우리로 하여금 runtime에 사용된 reference들이 반드시 valid한 것을 보장하게
만들기 위해 generic lifetime parameter를 써서 관계를 표현하도록 유도합니다.

Lifetime을 명시하는 것은 다른 거의 모든 언어에서는 있지도 않습니다. 그렇기
때문에 unfamiliar할 수 있습니다. 이 챕터에서 우리는 lifetime의 모든 것을
다루지는 않습니다. 대신  lifetime syntax를 마주칠 몇 가지 방식에 대해 소개해서
당신이 lifetime에 익숙해지도록 돕습니다. 

## 10_3_1 Prevent Dangling References with Lifetimes

Lifetime의 메인 목적은 _dangling reference_를 방지하는 것입니다. dangling reference는
프로그램이 실제 의도와 다른 데이터를 reference할 위험을 낳습니다.

```rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
    }

    println!("r: {}", r);
}
```
이 예시, 다음 예시, 그리고 10-23 예시는 변수의 initial value를 선언하지 않고
declare하기만 했으므로, 변수명은 outer scope에 존재합니다. Rust가 null value를
가지지 않는다는 룰과 대치되는 것으로 보일 수 있으나, 이 variable에 값을 넣기
전에 사용하려고 들면 컴파일 에러가 발생합니다. 즉 Rust가 null value를 허용하지
않는다는 룰은 여전히 유효합니다.

- 아무튼.. 바깥쪽 scope에서 r을 initial value 없이 선언했고, 안쪽 scope에서 x를
    initial value 줘서 선언했습니다. 그리고 r에 x의 reference를 할당했습니다. 그
    다음 inner scope가 종료되었는데, 그 상태에서 r을 출력하려고 했습니다. x가
    이미 scope 밖으로 벗어났는데 r이 해당 reference를 가지고 있으므로 dangling이
    발생합니다. 컴파일 에러 메세지에도 `x dropped here while still borrowed`라고
    나오고요. 그런 와중에 r은 outer scope에서도 valid하기 때문에, Rust가 이
    코드를 허용했다면 deallocated memory를 가리키는 상태였을 것이고, `r`을
    사용한 모든 코드가 제대로 동작하지 않았을 겁니다.
- Rust가 코드 유효성을 어떻게 검사할까요? Borrow checker를 사용합니다.

## 10_3_2 The Borrow Checker

Rust 컴파일러는 scope를 비교하는 borrow checker를 가져서 모든 borrowing들이
valid한지 검사합니다.
```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {}", r); //          | a는 이 시점에 살아있지만 a가 빌린 b가
    // 죽어있으므로 reject됩니다.
}                         // ---------+
////// -----vs-----
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {}", r); //   |       | // r이 마지막으로 사용된 시점보다 x가
    // 더 오래 남아있으므로 accept됩니다.
                          // --+       |
}                         // ----------+
```

## 10_3_3 Generic LIfetimes in Functions

예를 들어 두 문자열 중 더 긴 것을 반환하는 함수를 작성한다고 합시다. 2개의
string slice를 받아서 하나를 반환합니다.

```rust
fn main() {
    let string1 = String::from("abcd");
    let string2 = "xyz";

    let result = longest(string1.as_str(), string2);
    println!("The longest string is {}", result);
}
```

이를 위한 longest 함수를 어떻게 작성해야 할까요? 참고로 string slice를
reference로 받게 하여 ownership을 넘겨주지 않아야 합니다. 그런데 다음과 같은
문제가 발생합니다.

```rust
fn longest(x: &str, y: &str) -> &str { // expected named lifetime param on x, y
                                        // and return
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

왜냐하면, 반환되는 reference가 x일지 y일지 모르기 때문입니다. (컴파일러도 우리도
모름) 이 함수를 선언할 때 어떤 값이 반환될지, 해당 값(레퍼런스)들의 lifetime이
어떻게 될지 모르기 때문에, 앞에서 살펴본 예제들과 다르게 lifetime analyze가
불가능합니다.
Borrow checker 역시 x와 y의 lifetime이 return value와 어떻게 relate될지
모릅니다.
이를 해소하려면, reference들 사이의 관계를 이어주는 generic lifetime parameter를
추가해서 borrow checker가 분석을 할 수 있도록 합니다.

## 10_3_3 Lifetime Annotation Syntax

사실 lifetime annotation을 추가해도 어떤 reference의 수명이 길어지지는 않습니다.
대신, 이것들은 여러 reference들의 lifetime 관계를 그것들의 lifetime 구간에
영향을 주지 않고 설명하는 데에 사용됩니다.
함수들이 generic type parameter가 signature에 있을 때 어떤 타입도 입력으로 받을
수 있듯이, generic lifetime parameter를 주면 해당 generic을 가진 reference들을
입력으로 받을 수 있습니다.

Lifetime annotation의 문법은 조금 복잡합니다. Lifetime의 이름은 반드시 `'`로
시작해야 하고, 대개 소문자로만 이뤄지고 매우 짧습니다(Generic type도 짧죠). 대개
`'a`를 첫 lifetime annotation으로 사용합니다.

Lifetime annotation은 reference의 `&`바로 뒤에 붙이고, space를 눌러서
reference의 type과 분리합니다.

```rust
&i32        // a reference
&'a i32     // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

Lifetime 그 자체로는 의미가 적습니다. 애초에 여러 reference들간의 관계를
설명하기 위해 만들어졌기 때문이죠. 앞에서 본 `longest` 함수를 어떻게 수정하는지
살펴봅시다.

## 10_4 Lifetime Annotation in Function Signatures

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str { // 반환되는 reference가
// 두 parameter만큼 valid해야 한다는 relationship
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

Generic type을 함수 parameter list 앞, struct definition 앞, Enum definition
앞에 썼던 것처럼, generic lifetime parameter 역시 같은 위치에 선언합니다.

위의 코드를 설명하자면 - function signature는 이제 어떤 lifetime `'a`에 대해,
함수가 2개의 parameter를 받는데 최소한 `'a` lifetime만큼은 살아있다고
알려줍니다. 실제로는 `longest`에 의해 반환된 reference의 lifetime은 둘 중 더
짧은 것 만큼 살아있습니다.

기억하세요 - lifetime parameter를 붙인다고 해서 lifetime이 바뀌지는 않는 것을.
대신, borrow checker에게 이렇게 알려주는 겁니다 - 이 constraint를 만족하지 않는
어떤 값이든 reject하라고. 그래서 이 함수를 호출할 때 `x` 및 `y`가 정확히 얼마나
오래 살아있을지를 알 필요가 없습니다.

Lifetime annotation 역시 parameter type, return type 등과 마찬가지로 function의
규약입니다. function이 annotate된 방식이나 call된 방식에 잘못이 있다면, compiler
error가 우리의 코드를 잡아주기 쉽죠. 만약 이러는 대신 Rust가 더 많은 추론을 해야
했다면, compiler는 실제 문제를 일으키는 line에서 멀리 떨어진, "사용이 문제가 된"
line을 우리에게 알려줬겠죠.

아무튼.. 실제 코드에서 concrete reference를 `longest`에게 주면, concrete
lifetime이 `'a` 대신 들어가는데, `x`와 `y`의 겹치는 만큼을 차지합니다. 따라서
반환되는 reference가 `'a`였으므로 x/y가 겹치는 만큼의 lifetime을 차지합니다.

이러한 lifetime annotation은 서로 다른 concrete lifetime을 가진 2개의
reference를 넘겨주는 데에 제한을 겁니다. 아래 두 예시를 비교해봅시다.

```rust
fn main() {
    let string1 = String::from("long string is long");

    {
        let string2 = String::from("xyz");
        let result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result);
    }
}

// ----vs----

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
    }
    println!("The longest string is {}", result); // error: string2가 이미
    // 죽었음, 우리는 하드코딩된 값에 따라 string1이 들어간다는 것을 알지만,
    // 컴파일러는 그렇게 생각하지 않는다.
}
```

우리는 인간이고, 하드코딩된 길이를 보고 'string1이 살아있으니까 코드가 돌아갈
거야'라고 생각하지만, 컴파일러는 그렇게 보지 않습니다. 더군다나 우리가 이미
컴파일러에게 둘 중 더 짧은 lifetime을 반환값이 가진다고 이야기했기 때문에, 이건
우리의 잘못입니다. Borrow checker는 위 코드가 invalid reference를 가질 수 있다고
말하게 됩니다.
