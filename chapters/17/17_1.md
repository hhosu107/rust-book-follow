# 17_1 OOP의 특징

사실 프로그래밍 커뮤니티에서 프로그래밍 언어가 객체지향적이라고 생각되기 위해 반드시 가져야 하는
특성 같은 기준은 없습니다.
러스트는 여러 프로그래밍 패러다임의 영향을 받았습니다. 물론 OOP를 포함해서요.
예를 들어 우리는 이미 closure와 iterator를 배웠습니다.
약간 논쟁의 대상이 되지만, 객체지향 프로그래밍 언어들은 여러 특성들을 공유합니다. 객체, 추상화,
그리고 상속 등의 특성들이죠. 그것들이 어떤 의미인지 살펴보고, 러스트가 그것들을 지원하는지 봅시다.

## 17_1_1 객체는 데이터와 행동을 담는다

책 _디자인 패턴: 객체지향 프로그래밍의 재사용성을 위한 요소들_은 객체지향 디자인 패턴의 카탈로그를
담고 있습니다. 여기서는 OOP를 다음과 같이 정의합니다.

```text
객체지향 프로그램은 객체로 만들어져있습니다. _객체_는 데이터와, 데이터에 동작하는 프로시져를
패키징한 것입니다. _프로시져_는 보통 _method_ 혹은 _operations_라고 불립니다.
```

이 정의에 따르면 러스트는 객체지향적입니다. Struct와 Enum이 데이터를 가지고, `impl` block은
struct/enum들에게 method를 제공합니다.
비록 struct/enum을 우리가 객체라고 부르지만, 이 책의 객체에 대한 정의에 따르면 같은 기능을
제공합니다.

## 17_1_2 추상화는 구현 명세를 숨긴다

OOP의 다른 특징은 _추상화_인데, 이것은 객체의 구현 명세는 객체에 접근하는 코드가 알 수 없다는
것입니다.
즉 객체와 상호작용하는 방법은 public API밖에 없다는 것으로, 객체를 사용하는 코드는 객체의 내부에
직접 접근하여 데이터나 행동을 직접 수정할 수 없습니다.
이를 통해 프로그래머가 객체의 내부 구현을 바꾸거나 리팩토링할 때 해당 객체를 사용하는 코드를 수정할
필요가 없습니다.

우리는 추상화 수준을 다루는 것에 대해 이미 Chapter 7에서 배웠습니다. `pub` 키워드를 모듈, 타입,
함수, 메소드에 사용하여 public하게 내보여야 할 것들을 결정할 수 있고, `pub` 없는 모든 것들은
기본적으로 private했었죠.
예를 들어, 다음과 같이 i32 벡터와 해당 벡터의 평균을 담는 struct를 생각해봅시다. 즉 평균은 객체가
만들어지고, 수정되는 매 순간순간 이미 계산되어, 평균을 필요로 할 때 on-demand하게 계산되는 것이
아니라는 것입니다. 다르게 말하면 이 struct는 우리를 위해 평균을 캐싱해두고 있다는 것입니다.

```rust
pub struct AveragedCollection {
    list: Vec<i32>,
    average: f64,
}
```

Struct는 `pub`이지만, 각 필드들은 private입니다. 이것이 중요한 이유는, 우리가 어떤 값들을 list에
넣고 뺄 때, 평균이 바로 업데이트되어야 하기 때문입니다. 이를 위해 우리는 `impl` block을 사용할
것입니다. `add, remove, average`를 추가합시다.

```rust
impl AveragedCollection {
    pub fn add(&mut self, value: i32) {
        self.list.push(value);
        self.update_average();
    }

    pub fn remove(&mut self) -> Option<i32> {
        let result = self.list.pop();
        match result {
            Some(value) => {
                self.update_average();
                Some(value)
            }
            None => None,
        }
    }

    pub fn average(&self) -> f64 {
        self.average
    }

    fn update_average(&mut self) {
        let total: i32 = self.list.iter().sum();
        self.average = total as f64 / self.list.len() as f64;
    }
}
```

이 method들이 해당 structure의 instance에 접근하거나 데이터를 수정하는 유일한 방법들입니다.
`list`에 `add`로 원소가 추가되거나 `remove`로 사라질 때, private인 `update_average`가 `average`
field를 함께 수정합니다.

`list`와 `average`는 여전히 private하므로 외부 코드가 `list` field의 아이템을 수정할 수 없습니다.
그렇게 하지 않으면 `average`가 실제 값과 sync되지 않습니다.
`average` method는 `average` field의 값을 반환하여, 외부 코드가 평균을 알게 해주는 동시에 수정할
수는 없게 합니다.

`AveragedCollection`의 구현 명세는 숨겼기 때문에, 이 struct를 위한 자료구조 등의 정보를 손쉽게 바꿀
수 있습니다.
예를 들면, `Vec<i32>`를 `HashSet<i32>`로 바꿔도, `add`나 `remove`, `average`의 signature가 동일하게
유지되는 한 이 struct를 사용하는 코드는 수정될 필요가 없습니다.
만약 `list`를 public하게 둬 버리면, `HashSet<i32>`와 `Vec<i32>`는 값을 추가하거나 제거할 때 서로
다른 method를 사용하기 때문에, public하게 나와있는 `list`를 직접 수정하는 코드가 있었다면 해당
코드도 수정되었어야 할 것입니다.

추상화가 객체지향적이기 위해 필요한 개념이라고 한다면, 러스트는 해당 요구사항을 충족시킵니다.
`pub`을 코드의 각 부분에서 사용하느냐 아니냐에 따라 구현 명세의 추상화 수준이 달라집니다.

## 17_1_3 Type System을 이용한 상속, 코드 공유를 이용한 상속

_상속_은 어떤 객체가 다른 객체의 정의로부터 원소들을 상속받는 메커니즘으로, 부모 객체의 데이터와
행동을 재정의하지 않도고 자동으로 얻어오는 것을 의미합니다.

언어가 객체지향적이기 위해 반드시 상속을 구현해야 한다면, 러스트는 객체지향적 언어가 아닙니다.
구조체가 부모 구조체의 field와 method를 자동으로 상속하도록 정의하는 것은, 매크로를 사용하지
않고서는 불가능합니다.

그러나, 당신이 프로그래밍 기법의 하나로 상속을 많이 사용해오고 있었다면, 당신은 상속을 사용하려던
목적이 무엇이냐에 따라 각기 다른 러스트의 솔루션들을 사용할 수 있습니다.

보통 당신은 크게 2가지 이유로 상속을 사용하려 합니다.
- 첫 번째: 코드 재사용.
당신은 특정 타입에 대해 특정 행동을 구현할 수 있고, 상속을 사용해서 해당 구현을 다른 타입에 사용할
수 있습니다.
이것을 러스트에서는 "기본 trait method 구현"을 통해 제한된 방식으로 따라할 수 있습니다. Chapter
10에서 기본 구현된 method를 Trait에 추가하는 방법을 배웠습니다.
따라서 해당 Trait을 구현하는 타입들은 기본 구현된 method를 아무런 코드 추가 없이 사용할 수
있습니다. 마치 부모 클래스가 method의 정의를 제공하고, 상속받은 자식 method가 해당 기본 구현된
method를 가지고 있는 것과 같습니다. 또한 해당 기본 구현 대신 Trait을 구현한 Type이 자신만의 구현을
추가할 수 있다는 점 역시 자식 class가 method를 override하는 것과 같습니다.

- 두 번째 이유는 타입 시스템과 관련되어 있습니다. 즉 부모 타입이 사용되었던 곳에 자식 타입이 그대로
    사용될 수 있게 하는 것입니다. 이를 _polymorphism(다형성)_이라고 하며, 이는 특정 객체들이 특정
    characteristic을 공유한다면 해당 object들이 런타임에 서로 대체될 수 있다는 뜻입니다.
  - 다형성
    - 많은 사람들에게, polymorphism 자체가 상속과 동의어로 여겨집니다. 그러나 다형성은 여러 타입의
        데이터를 다루는 코드를 부르는 더 큰 개념입니다. 상속 개념에서는, 이러한 타입들을
        subclass라고 부릅니다. 반대로, 러스트에서는 generic을 여러 가능한 다른 타입들을 추상화는
        데에 쓰고, trait bound를 이 타입들이 반드시 제공해야 하는 제한으로 사용합니다. 이것을 때로
        bounded parametric polymorphism이라고 부릅니다.

최근 들어, 상속 개념은 많은 프로그래밍 언어의 디자인 솔루션에서 사라지고 있는 추세입니다. 때로
필요한 것 보다 많은 코드를 공유하는 위험이 있기 때문입니다.
Subclass들은 기본적으로 부모 클래스의
모든 character를 항상 공유하지는 않아야 하지만, 상속을 하게 되면 항상 공유하게 됩니다.
이 때문에 프로그램의 디자인이 경직되게 됩니다.
또한, subclass에서 상속받아온 method를 그대로 사용하면 subclass의 구현 명세가 달라짐으로 인해 말이
되지 않는 값이 생성되거나 에러가 발생할 수 있습니다.
이에 더해, 일부 언어들은 상속을 1개의 class에서만 할 수 있게 제한하거나, 프로그램 디자인 자체를
제한하기도 합니다.

이러한 이유들로 인해, 러스트는 상속을 하는 대신 Trait object를 사용합니다.
Trait object가 러스트에서 다형성을 어떻게 구현하는지 알아보겠습니다.
