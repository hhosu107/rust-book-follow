# 19_1. Unsafe Rust

지금까지 우리가 다룬 코드들은 러스트의 memory safety 보장 (컴파일 타임에 이뤄짐)을 가지고
있었습니다. 그러나 러스트는 이러한 메모리 안전성 보장을 강제하지 않는 _unsafe Rust_를 가지고
있습니다. 이것은 일반적인 Rust처럼 동작하지만, 추가적인 superpower를 제공합니다.

Unsafe Rust가 존재하는 것은, 자연적으로, static analysis는 conervative하기 때문입니다.
컴파일러가 코드가 특정 보장을 만족하는지 결정하려면, invalid program을 일부 받아들이는 것 보다 valid
program을 일부 거부하는 것이 더 좋습니다.
어떤 코드는 _아마도_ 올바를지라도, Rust가 확신할 만한 정보가 충분하지 않다면, Rust는 그 코드를 거부할
것입니다. 이러한 경우 unsafe code를 사용하여, 컴파일러에게 "내가 무엇을 하는지 알고 있다"라고
말해주는 겁니다.
그러나 경고합니다. 당신이 unsafe Rust를 쓰는 것은 당신 스스로 짊어질 일입니다. 당신이 unsafe code를
잘못 사용하면, memory unsafety로 인한 문제가 발생할 것입니다. 예를 들면 null pointer dereferencing과
같은 일들이요.

Rust가 unsafe를 가지고 있는 또다른 이유는 (그것이 러스트의 이념을 거스르는 일임에도) 컴퓨터의
하드웨어 자체가 unsafe하기 때문입니다. 러스트가 unsafe operation을 하나도 허용하지 않는다면,
하드웨어의 기능 중 일부를 사용할 수 없습니다.
러스트는 low level system programming을 지원해야 합니다. 예를 들면 OS와 직접 상호작용한다거나,
자신만의 OS를 작성한다거나 하는 것처럼요. low-level system programming을 다루는 것은 언어들의 목표
중 하나입니다. 우리가 그러면 unsafe Rust로 뭘 할 수 있는지 봅시다.

## 19_1_1 Unsafe Superpowers

Unsafe Rust를 사용하려면, `unsafe` keyword를 쓰고 unsafe code를 감싸는 새 block을 만들어야 합니다.
Unsafe Rust에서는 safe Rust에서 할 수 없는 5가지 액션을 취할 수 있습니다. 따라서 _unsafe
superpower_라고 부릅니다. 이 superpower에는 다음이 포함되어 있습니다.

- Raw pointer dereferencing
- Unsafe한 function/method 부르기
- Mutable static variable을 수정하기
- Unsafe trait 구현하기
- `union`의 field에 접근하기

`unsafe`를 쓴다 해도 borrow checker를 끄거나 다른 Rust의 안전성 체크를 끄지 않습니다.
당신이 unsafe code에서 reference를 사용하면, 해당 내역은 여전히 체크됩니다.
`unsafe` keyword는 단지 당신에게 컴파일러가 메모리 안전성 체크를 하지 않는 위의 5가지 기능에 대한
접근을 제공할 뿐입니다. 여전히 당신은 unsafe block 안에서도 일정 수준의 안전성을 보장받습니다.

이에 더해, `unsafe`는 block 안의 코드가 위험해야만 한다는 것을 뜻하지 않으며, 또한 분명히 메모리
문제를 가진다 라는 것이 아닙니다. `unsafe`가 가지는 의도는, 프로그래머로서 당신이 `unsafe` block
안에서 메모리에 올바른 방식으로 접근한다는 것을 보장한다는 의미입니다.

사람들은 실패합니다. 또한 실수는 발생합니다. 그러나 위의 5가지 기능들을 `unsafe` block에
넣어줌으로서 당신은 어떠한 메모리 안전성에 관련된 에러라도 `unsafe` block에서 발생했다는 것을 알 수
있습니다.
물론 `unsafe` block은 작게 유지해야 합니다. 당신이 나중에 메모리 버그를 분석할 때 `unsafe` block이
작음으로서 도움을 받을 것입니다.

Unsafe code를 최대한 다른 코드들로부터 분리하기 위해, unsafe code를 감싸는 가장 좋은 방법은 안전한
추상화 안에 감싸서 safe API를 제공하는 것입니다. 이와 관련하여 다음 section에서 unsafe function,
method를 examine하는 방법을 배울 것입니다.
Standard library의 일부는 unsafe 함수들을 안전한 추상화로 감싼 채 구현되어 있습니다.
Unsafe code를 안전한 추상화로 감싸는 것은 `unsafe`를 어디에서든 사용해서 당신이나 당신의 유저들이
`unsafe` 코드로 구현된 기능을 쓸 때 새어나가는 위험을 줄여줍니다. 안전한 추상화를 사용하는 것은
안전하기 때문입니다.

각 5가지 unsafe superpower를 알아봅시다. 또한 몇 가지 abstraction을 살펴보고 unsafe code를 위한
안전한 인터페이스를 제공하는 추상화를 알아보겠습니다.

## 19_1_2 Dereferencing a Raw Pointer

Chapter 4의 Dangling References section에서, 우리는 컴파일러가 reference가항상 valid함을 보장한다고
했습니다.
Unsafe Rust는 이에 더해 2개의 새로운 타입들을 가지고 있는데, 이것들은 _raw pointers_라고 부릅니다.
Reference와 마찬가지로, raw pointer는 immutable하거나 mutable합니다. 각각 `*const T`와 `*mut T`로
나뉩니다.
이 때 사용하는 asterisk는 dereference operator가 아니며, 타입 이름의 일부입니다. Raw pointer
context에서, _immutable_은 pointer가 dereference된 다음에 값을 강제로 assign받을 수 없다는 것을
뜻합니다.

Reference와 smart pointer와는 달리, raw pointer들은:

- Borrowing rule들을 무시합니다. 즉, immutable pointer와 mutable pointer를 동시에 가지거나, 여러
    개의 mutable pointer를 한 곳에서 동시에 가질 수 있습니다.
- valid memory를 point함이 보장되지 않습니다.
- null일 수 있습니다.
- 자동 cleanup을 하나도 구현하지 않습니다.

이렇게 Rust가 보장하는 것들을 제거함으로서, 당신은 안전성을 잃어버리는 대신 더 높은 성능 혹은,
Rust의 guarantee가 적용되지 않는 다른 언어나 하드웨어와의 interface를 만들 수 있습니다.

아래에 immutable/mutable raw pointer를 reference로부터 얻는 예제가 있습니다.

```rust
    let mut num = 5;

    let r1 = &num as *const i32; // type casting
    let r2 = &mut num as *mut i32; // type casting
```

여기서 알 수 있는 것은, 우리가 raw pointer를 만드는 것 자체는 `unsafe` block 안에서 할 필요가 없다
라는 사실입니다. 단지 우리는 unsafe block 밖에서 raw pointer를 dereference하는 것은 할 수 없다는
것만을 알고 있으면 됩니다.
Raw pointer를 `as` cast operator를 사용해서 immutable/mutable하게 만들었습니다.
Reference로부터 직접 만들었기 때문에 우리는 정확히 저 pointer들이 valid하다는 것을 알고 있습니다.
그러나 이러한 가정을 모든 raw pointer에 대해 할 수는 없습니다.

Counter part를 확인하기 위해, 우리는 raw pointer의 유효성이 보장되지 않는 예시를 만들 것입니다.
다음 예시는 메모리의 임의의 지점에 raw pointer를 만드는 방법을 보여줍니다.
임의의 memory를 사용하는 것은 undefined behavior입니다. 그 memory address에는 이미 기존의 데이터가
있을 수도, 아닐 수도 있습니다. 컴파일러가 이를 최적화하여 메모리 액세스가 없도록 하거나, 프로그램이
segmentation fault를 낼 것입니다. 보통 이런 코드를 작성할 좋은 이유가 없지만, 가능은 합니다.

```rust
    let address = 0x012345usize;
    let r = address as *const i32;
```

이제 unsafe block 안에서 _dereference_해봅시다.

```rust
    let mut num = 5;

    let r1 = &num as *const i32;
    let r2 = &mut num as *mut i32;

    unsafe {
        println!("r1 is: {}", *r1);
        println!("r2 is: {}", *r2);
    }
```

Pointer를 만드는 것은 우리에게 해를 끼치지 않습니다. 단지 invalid value를 다루는 pointer의 값에
접근할 때 문제가 됩니다.

또한 같은 scope 안에서 immutable/mutable raw pointer를 동시에 만든 것을 확인할 수 있습니다.
단순히 `let r1 = &num; let r2 = &mut num;`이라고만 했으면 Ownership rule에 의해 금지되었을 것입니다.
Raw pointer를 사용하면, 몇 개의 mutable pointer든지 몇 개의 immutable pointer든지 동시에 만들 수
있습니다. 또한 여러 mutable pointer에서 동시에 data를 수정할 수도 있는데, 이 때 일어날 수 있는 data
race에 주의하세요.

이런 위험을 감수하고 Raw pointer를 쓸 이유가 뭘까요? 가장 큰 use case는 C code와의
interfacing입니다. 당신이 다음 section인 "Calling an Unsafe Function or Method"에서 배울 것처럼.
다른 케이스는 당신이 borrow checker가 이해할 수 없는 안전한 추상화를 만들 때입니다.
우리는 unsafe function/method를 소개하고 unsafe code를 사용하는 안전한 abstraction에 대해 알아볼
것입니다.
